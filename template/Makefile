# =============================================================================
# PSX Decompilation Project Makefile
# =============================================================================
# This Makefile provides the build infrastructure for a PSX decompilation
# project using splat and the GCC 2.6/2.7 era PSX toolchain.
#
# Based on conventions from sotn-decomp, open-ribbon, and other PSX decomps.
# =============================================================================

# -----------------------------------------------------------------------------
# Configuration - Adjust these for your project
# -----------------------------------------------------------------------------

# Project name (used for output files)
PROJECT := game

# Game version (us, eu, jp, etc.)
VERSION := us

# Target binary (the original PSX executable to match)
TARGET := disks/$(VERSION)/SLUS_000.00

# Splat configuration file
SPLAT_CONFIG := config/splat.$(VERSION).yaml

# Build output directory
BUILD_DIR := build/$(VERSION)

# ASM output directory (from splat)
ASM_DIR := asm/$(VERSION)

# Source directory
SRC_DIR := src

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Toolchain Configuration
# -----------------------------------------------------------------------------

# GCC 2.95.3 TOOLCHAIN (From Nix minimal-bootstrap)
# =================================================
# The flake provides GCC 2.95.3 via Nix's minimal-bootstrap package.
# This matches PSY-Q 4.6/4.7's CC1PSX.EXE compiler output.
#
# NO EXTERNAL DOWNLOADS REQUIRED - everything comes from Nix!
#
# The GCC295_PATH environment variable is set by the flake's shellHook.
# If you need a different GCC version (2.7.2, 2.8.1, etc.), you can:
#   1. Download from decompals/old-gcc: ./tools/download-toolchain.sh 2.7.2
#   2. Override GCC_DIR below

# GCC from Nix (set by flake) or fallback to downloaded version
ifdef GCC295_PATH
  CC1 := $(GCC295_PATH)/bin/cc1
  GCC := $(GCC295_PATH)/bin/gcc
else
  # Fallback: downloaded old-gcc
  GCC_VERSION := 2.95.2
  GCC_DIR := tools/gcc-$(GCC_VERSION)
  CC1 := $(GCC_DIR)/cc1
  GCC := $(GCC_DIR)/gcc
endif

# MIPS cross-toolchain (from Nix environment)
# Note: Nix provides mipsel-unknown-linux-gnu-*, not mipsel-linux-gnu-*
# The binutils (as, ld, objcopy) are version-independent for linking
CROSS := mipsel-unknown-linux-gnu-
AS := $(CROSS)as
LD := $(CROSS)ld
OBJCOPY := $(CROSS)objcopy
CPP := cpp
STRIP := $(CROSS)strip

# maspsx - Modern ASPSX replacement
# Transforms GCC assembly output to match PSY-Q ASPSX.EXE behavior
# See: https://github.com/mkst/maspsx
MASPSX := python3 tools/maspsx/maspsx.py

# maspsx configuration (adjust based on your game's PSY-Q version)
# PSY-Q 3.3 -> --aspsx-version=2.21
# PSY-Q 3.5 -> --aspsx-version=2.34
# PSY-Q 4.0 -> --aspsx-version=2.56
# PSY-Q 4.1 -> --aspsx-version=2.67
# PSY-Q 4.3 -> --aspsx-version=2.77
# PSY-Q 4.4 -> --aspsx-version=2.79
# PSY-Q 4.5 -> --aspsx-version=2.81
# PSY-Q 4.6 -> --aspsx-version=2.86
# PSY-Q 4.7 -> --aspsx-version=2.86 (same as 4.6)
ASPSX_VERSION := 2.86
MASPSX_FLAGS := --aspsx-version=$(ASPSX_VERSION) --run-assembler --gnu-as-path=$(AS)

# Python (from Nix environment)
PYTHON := python3

# splat binary splitting tool
SPLAT := $(PYTHON) -m splat split

# m2c - MIPS to C decompiler
M2C := $(PYTHON) tools/m2c/m2c.py
SPLAT := $(PYTHON) -m splat split

# m2c - MIPS to C decompiler
M2C := $(PYTHON) tools/m2c/m2c.py

# -----------------------------------------------------------------------------
# Compiler Flags
# -----------------------------------------------------------------------------

# C preprocessor flags
CPPFLAGS := -I include -I include/psxsdk -D_LANGUAGE_C -DVERSION_$(VERSION)

# PSX compiler flags (GCC 2.6 compatible)
# -O2: Optimization level 2
# -G0: No global pointer optimization (required for overlays)
# -fno-builtin: Don't use builtin functions
# -mno-abicalls: No PIC/position independent code
# -mcpu=3000: MIPS R3000 (PSX CPU)
CFLAGS := -O2 -G0 -fno-builtin -mno-abicalls -mcpu=3000

# Assembler flags
ASFLAGS := -march=r3000 -mtune=r3000 -no-pad-sections -G0

# Linker flags
LDFLAGS := -nostdlib

# -----------------------------------------------------------------------------
# File Discovery
# -----------------------------------------------------------------------------

# Find all C source files
C_SRCS := $(shell find $(SRC_DIR) -name '*.c' 2>/dev/null)

# Find all ASM source files (from splat extraction)
S_SRCS := $(shell find $(ASM_DIR) -name '*.s' 2>/dev/null)

# Object files
C_OBJS := $(C_SRCS:$(SRC_DIR)/%.c=$(BUILD_DIR)/%.c.o)
S_OBJS := $(S_SRCS:$(ASM_DIR)/%.s=$(BUILD_DIR)/%.s.o)

# All object files
OBJS := $(C_OBJS) $(S_OBJS)

# Linker script (generated by splat)
LD_SCRIPT := $(BUILD_DIR)/$(PROJECT).ld

# -----------------------------------------------------------------------------
# Targets
# -----------------------------------------------------------------------------

.PHONY: all clean extract expected diff context check tools help

# Default target
all: $(BUILD_DIR)/$(PROJECT).bin
	@echo "Build complete!"

# Show help
help:
	@echo "PSX Decompilation Project (Modern Workflow)"
	@echo "============================================"
	@echo ""
	@echo "Toolchain: GCC $(GCC_VERSION) + maspsx (ASPSX $(ASPSX_VERSION))"
	@echo ""
	@echo "Targets:"
	@echo "  all              - Build the project (default)"
	@echo "  extract          - Extract/disassemble binary using splat"
	@echo "  expected         - Copy original binary to expected/"
	@echo "  check            - Verify build matches original"
	@echo "  clean            - Remove build artifacts"
	@echo ""
	@echo "Decompilation:"
	@echo "  diff FUNC=name   - Compare function with asm-differ"
	@echo "  decompile FUNC=f - Decompile function with m2c"
	@echo "  context          - Generate ctx.c for m2c"
	@echo "  permuter FUNC=f  - Run decomp-permuter"
	@echo ""
	@echo "Tools:"
	@echo "  tools            - Download GCC toolchain"
	@echo "  detect-compiler  - Analyze binary's compiler"
	@echo ""
	@echo "Workflow:"
	@echo "  1. ./tools/download-toolchain.sh"
	@echo "  2. Place binary in disks/$(VERSION)/"
	@echo "  3. make extract"
	@echo "  4. make"
	@echo "  5. make check"
	@echo ""

# -----------------------------------------------------------------------------
# Extraction (splat)
# -----------------------------------------------------------------------------

extract: $(SPLAT_CONFIG)
	@echo "Extracting binary using splat..."
	$(SPLAT) $(SPLAT_CONFIG)
	@echo "Extraction complete. ASM files in $(ASM_DIR)/"

# -----------------------------------------------------------------------------
# Compilation Rules
# -----------------------------------------------------------------------------

# Create build directories
$(BUILD_DIR)/:
	mkdir -p $@

# Compile C to object file using old-gcc + maspsx pipeline
# This is the MODERN approach that doesn't require wine/dosemu2:
#   1. Preprocess with system cpp
#   2. Compile with old gcc cc1 (same codegen as PSY-Q)
#   3. Pass through maspsx (replicates ASPSX.EXE behavior)
#   4. Assemble with GNU as (via maspsx --run-assembler)
#
# The maspsx wrapper handles:
#   - $gp-relative addressing
#   - NOP insertion for pipeline hazards
#   - div/rem expansion
#   - .comm/.sdata handling
$(BUILD_DIR)/%.c.o: $(SRC_DIR)/%.c | $(BUILD_DIR)/
	@mkdir -p $(dir $@)
	@echo "CC $<"
	$(CPP) $(CPPFLAGS) $< | $(CC1) $(CFLAGS) -o $(BUILD_DIR)/$*.s
	$(MASPSX) $(MASPSX_FLAGS) $(ASFLAGS) $(BUILD_DIR)/$*.s -o $@

# Assemble ASM files (from splat extraction or handwritten)
$(BUILD_DIR)/%.s.o: $(ASM_DIR)/%.s | $(BUILD_DIR)/
	@mkdir -p $(dir $@)
	@echo "AS $<"
	@$(AS) $(ASFLAGS) $< -o $@

# -----------------------------------------------------------------------------
# Linking
# -----------------------------------------------------------------------------

# Link all objects into ELF
$(BUILD_DIR)/$(PROJECT).elf: $(OBJS) $(LD_SCRIPT)
	@echo "LD $@"
	@$(LD) $(LDFLAGS) -T $(LD_SCRIPT) -Map $(BUILD_DIR)/$(PROJECT).map -o $@ $(OBJS)

# Convert ELF to raw binary (PSX format)
$(BUILD_DIR)/$(PROJECT).bin: $(BUILD_DIR)/$(PROJECT).elf
	@echo "OBJCOPY $@"
	@$(OBJCOPY) -O binary $< $@

# -----------------------------------------------------------------------------
# Verification
# -----------------------------------------------------------------------------

# Create expected directory with original binary for comparison
expected: $(TARGET)
	@mkdir -p expected/$(VERSION)
	@cp $(TARGET) expected/$(VERSION)/
	@echo "Copied original to expected/$(VERSION)/"

# Check if build matches original
check: $(BUILD_DIR)/$(PROJECT).bin $(TARGET)
	@echo "Comparing build to original..."
	@sha1sum $(BUILD_DIR)/$(PROJECT).bin $(TARGET)
	@if cmp -s $(BUILD_DIR)/$(PROJECT).bin $(TARGET); then \
		echo "✓ BUILD MATCHES ORIGINAL"; \
	else \
		echo "✗ BUILD DOES NOT MATCH"; \
		exit 1; \
	fi

# -----------------------------------------------------------------------------
# Diff Tools
# -----------------------------------------------------------------------------

# Run asm-differ on a function
# Usage: make diff FUNC=FunctionName
diff:
ifndef FUNC
	@echo "Usage: make diff FUNC=FunctionName"
	@exit 1
endif
	$(PYTHON) tools/asm-differ/diff.py -mwo3 $(FUNC)

# m2c - Decompile a function from assembly to C
# Usage: make decompile FUNC=func_80012345
decompile:
ifndef FUNC
	@echo "Usage: make decompile FUNC=func_80012345"
	@exit 1
endif
	$(M2C) --target mipsel-gcc-c --context ctx.c asm/$(VERSION)/nonmatchings/$(FUNC).s

# Generate ctx.c context file for m2c/decomp.me
# This creates a preprocessed version of all headers for m2c
context: ctx.c

ctx.c:
	@echo "Generating context file..."
	$(CPP) -P $(CPPFLAGS) include/common.h > ctx.c
	@echo "Context saved to ctx.c"

# Import function into decomp-permuter
# Usage: make permuter-import FILE=src/main.c FUNC=FunctionName
permuter-import:
ifndef FILE
	@echo "Usage: make permuter-import FILE=src/main.c FUNC=FunctionName"
	@exit 1
endif
	$(PYTHON) tools/decomp-permuter/import.py $(FILE)

# Run decomp-permuter on imported function
# Usage: make permuter FUNC=FunctionName
permuter:
ifndef FUNC
	@echo "Usage: make permuter FUNC=FunctionName"
	@exit 1
endif
	$(PYTHON) tools/decomp-permuter/permuter.py nonmatchings/$(FUNC) --best-only -j4

# -----------------------------------------------------------------------------
# Tools
# -----------------------------------------------------------------------------

# Download toolchain binaries (old-gcc from decompals)
tools:
	./tools/download-toolchain.sh

# Detect compiler signature in target binary
# This helps identify which GCC version was used originally
detect-compiler:
	@echo "Analyzing binary for compiler signatures..."
	@if strings $(TARGET) 2>/dev/null | grep -q "GCC:"; then \
		echo "GCC signature found:"; \
		strings $(TARGET) | grep "GCC:" | head -5; \
	fi
	@if strings $(TARGET) 2>/dev/null | grep -qi "psyq"; then \
		echo "PSY-Q references found:"; \
		strings $(TARGET) | grep -i "psyq" | head -5; \
	fi
	@echo ""
	@echo "Common GCC versions for PSX:"
	@echo "  PSY-Q 4.6 -> GCC 2.95.2"
	@echo "  PSY-Q 4.4/4.5 -> GCC 2.91.66 (egcs 1.1.2)"
	@echo "  PSY-Q 4.0-4.3 -> GCC 2.8.x"
	@echo "  PSY-Q 3.x -> GCC 2.7.2 or 2.6.x"

# -----------------------------------------------------------------------------
# Cleanup
# -----------------------------------------------------------------------------

clean:
	rm -rf $(BUILD_DIR)
	rm -rf asm
	rm -rf assets

# Clean only build artifacts, keep extracted files
clean-build:
	rm -rf $(BUILD_DIR)

# -----------------------------------------------------------------------------
# Progress Tracking
# -----------------------------------------------------------------------------

# Calculate decompilation progress
progress:
	@$(PYTHON) tools/progress.py $(BUILD_DIR)/$(PROJECT).map $(TARGET)
